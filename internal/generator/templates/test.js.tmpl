// Test suite for {{.Name}} ({{.Symbol}})
// Generated by erc20gen — https://github.com/Zubimendi/erc20gen
// Framework: Hardhat + Chai
// Run: npx hardhat test

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { loadFixture } = require("@nomicfoundation/hardhat-toolbox/network-helpers");

describe("{{.SafeName}}", function () {
  // ─── Fixtures ──────────────────────────────────────────────────────────────

  async function deployFixture() {
    const [owner, addr1, addr2, ...addrs] = await ethers.getSigners();
    const {{.SafeName}} = await ethers.getContractFactory("{{.SafeName}}");
{{- if or .NeedsOwnable .NeedsRoles}}
    const token = await {{.SafeName}}.deploy(owner.address);
{{- else}}
    const token = await {{.SafeName}}.deploy();
{{- end}}
    await token.waitForDeployment();
    return { token, owner, addr1, addr2, addrs };
  }

  // ─── Deployment ────────────────────────────────────────────────────────────

  describe("Deployment", function () {
    it("Should have correct name and symbol", async function () {
      const { token } = await loadFixture(deployFixture);
      expect(await token.name()).to.equal("{{.Name}}");
      expect(await token.symbol()).to.equal("{{.Symbol}}");
    });

    it("Should have {{.Decimals}} decimals", async function () {
      const { token } = await loadFixture(deployFixture);
      expect(await token.decimals()).to.equal({{.Decimals}});
    });
{{- if .InitialSupply}}

    it("Should mint initial supply to deployer", async function () {
      const { token, owner } = await loadFixture(deployFixture);
      const decimals = await token.decimals();
      const expected = ethers.parseUnits("{{.InitialSupply}}", decimals);
      expect(await token.totalSupply()).to.equal(expected);
      expect(await token.balanceOf(owner.address)).to.equal(expected);
    });
{{- end}}
{{- if .MaxSupply}}

    it("Should have correct cap", async function () {
      const { token } = await loadFixture(deployFixture);
      const decimals = await token.decimals();
      const expectedCap = ethers.parseUnits("{{.MaxSupply}}", decimals);
      expect(await token.cap()).to.equal(expectedCap);
    });
{{- end}}
  });

  // ─── Transfers ─────────────────────────────────────────────────────────────

  describe("Transfers", function () {
    it("Should transfer tokens between accounts", async function () {
      const { token, owner, addr1 } = await loadFixture(deployFixture);
      const amount = ethers.parseUnits("100", await token.decimals());
      await expect(token.transfer(addr1.address, amount))
        .to.emit(token, "Transfer")
        .withArgs(owner.address, addr1.address, amount);
    });

    it("Should fail when sender has insufficient balance", async function () {
      const { token, addr1, addr2 } = await loadFixture(deployFixture);
      const amount = ethers.parseUnits("1", await token.decimals());
      await expect(token.connect(addr1).transfer(addr2.address, amount))
        .to.be.revertedWithCustomError(token, "ERC20InsufficientBalance");
    });

    it("Should not allow transfer to zero address", async function () {
      const { token, owner } = await loadFixture(deployFixture);
      const amount = ethers.parseUnits("1", await token.decimals());
      await expect(token.transfer(ethers.ZeroAddress, amount))
        .to.be.revertedWithCustomError(token, "ERC20InvalidReceiver");
    });
  });

  // ─── Approvals ─────────────────────────────────────────────────────────────

  describe("Approvals", function () {
    it("Should approve and transferFrom correctly", async function () {
      const { token, owner, addr1, addr2 } = await loadFixture(deployFixture);
      const amount = ethers.parseUnits("50", await token.decimals());
      await token.approve(addr1.address, amount);
      await token.connect(addr1).transferFrom(owner.address, addr2.address, amount);
      expect(await token.balanceOf(addr2.address)).to.equal(amount);
    });

    it("Should emit Approval event", async function () {
      const { token, owner, addr1 } = await loadFixture(deployFixture);
      const amount = ethers.parseUnits("100", await token.decimals());
      await expect(token.approve(addr1.address, amount))
        .to.emit(token, "Approval")
        .withArgs(owner.address, addr1.address, amount);
    });
  });
{{- if .Mintable}}

  // ─── Minting ───────────────────────────────────────────────────────────────

  describe("Minting", function () {
    it("Should allow authorized minting", async function () {
      const { token, owner, addr1 } = await loadFixture(deployFixture);
      const amount = ethers.parseUnits("500", await token.decimals());
      await expect(token.mint(addr1.address, amount))
        .to.emit(token, "Transfer")
        .withArgs(ethers.ZeroAddress, addr1.address, amount);
    });

    it("Should reject unauthorized minting", async function () {
      const { token, addr1, addr2 } = await loadFixture(deployFixture);
      const amount = ethers.parseUnits("1", await token.decimals());
      await expect(token.connect(addr1).mint(addr2.address, amount))
        .to.be.reverted;
    });

    it("Should not allow minting to zero address", async function () {
      const { token } = await loadFixture(deployFixture);
      const amount = ethers.parseUnits("1", await token.decimals());
      await expect(token.mint(ethers.ZeroAddress, amount))
        .to.be.revertedWithCustomError(token, "ERC20InvalidReceiver");
    });
  });
{{- end}}
{{- if .Burnable}}

  // ─── Burning ───────────────────────────────────────────────────────────────

  describe("Burning", function () {
    it("Should allow token holders to burn their tokens", async function () {
      const { token, owner } = await loadFixture(deployFixture);
      const amount = ethers.parseUnits("100", await token.decimals());
      const balanceBefore = await token.balanceOf(owner.address);
      await token.burn(amount);
      expect(await token.balanceOf(owner.address)).to.equal(balanceBefore - amount);
    });

    it("Should reduce total supply on burn", async function () {
      const { token, owner } = await loadFixture(deployFixture);
      const amount = ethers.parseUnits("100", await token.decimals());
      const supplyBefore = await token.totalSupply();
      await token.burn(amount);
      expect(await token.totalSupply()).to.equal(supplyBefore - amount);
    });
  });
{{- end}}
{{- if .Pausable}}

  // ─── Pause ─────────────────────────────────────────────────────────────────

  describe("Pausable", function () {
    it("Should block transfers when paused", async function () {
      const { token, owner, addr1 } = await loadFixture(deployFixture);
      await token.pause();
      const amount = ethers.parseUnits("1", await token.decimals());
      await expect(token.transfer(addr1.address, amount))
        .to.be.revertedWithCustomError(token, "EnforcedPause");
    });

    it("Should allow transfers after unpause", async function () {
      const { token, owner, addr1 } = await loadFixture(deployFixture);
      await token.pause();
      await token.unpause();
      const amount = ethers.parseUnits("1", await token.decimals());
      await expect(token.transfer(addr1.address, amount)).not.to.be.reverted;
    });

    it("Should reject pause from non-authorized caller", async function () {
      const { token, addr1 } = await loadFixture(deployFixture);
      await expect(token.connect(addr1).pause()).to.be.reverted;
    });
  });
{{- end}}

  // ─── Security edge cases ───────────────────────────────────────────────────

  describe("Security", function () {
    it("Should handle zero amount transfers gracefully", async function () {
      const { token, owner, addr1 } = await loadFixture(deployFixture);
      await expect(token.transfer(addr1.address, 0)).not.to.be.reverted;
    });

    it("Should handle max uint256 approval (infinite approval pattern)", async function () {
      const { token, owner, addr1 } = await loadFixture(deployFixture);
      const maxUint = ethers.MaxUint256;
      await token.approve(addr1.address, maxUint);
      expect(await token.allowance(owner.address, addr1.address)).to.equal(maxUint);
    });
  });
});
