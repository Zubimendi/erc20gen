// SPDX-License-Identifier: {{.License}}
// Generated by erc20gen — https://github.com/Zubimendi/erc20gen
// ⚠️  SECURITY: Audit this contract before deploying to mainnet.
// Run: slither contracts/{{.ContractFileName}} && echidna-test . --contract {{.SafeName}}
pragma solidity {{.SolidityVersion}};

{{- range .ImportPaths}}
import "{{.}}";
{{- end}}

/**
 * @title {{.Name}}
 * @dev ERC-20 Token — {{.Symbol}}
 *
 * Features:
{{- if .Mintable}}
 *   ✓ Mintable        — authorized callers can mint new tokens
{{- end}}
{{- if .Burnable}}
 *   ✓ Burnable        — token holders can burn their balance
{{- end}}
{{- if .Pausable}}
 *   ✓ Pausable        — emergency pause of all transfers
{{- end}}
{{- if .Permit}}
 *   ✓ Permit (2612)   — gasless approvals via EIP-2612 signatures
{{- end}}
{{- if .Snapshot}}
 *   ✓ Snapshot        — balance snapshots for governance
{{- end}}
{{- if .Votes}}
 *   ✓ Votes           — on-chain voting delegation
{{- end}}
{{- if .MaxSupply}}
 *   ✓ Capped Supply   — maximum {{.MaxSupply}} tokens
{{- end}}
 *
 * Access Control: {{.AccessControl}}
 * Generated: erc20gen v1.0.0
 */
contract {{.SafeName}} is ERC20{{- range .InheritanceList}}, {{.}}{{end}} {
{{- if .NeedsRoles}}

    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant SNAPSHOT_ROLE = keccak256("SNAPSHOT_ROLE");
{{- end}}

    /**
     * @dev Initializes the token with name, symbol, and initial supply.
     *      Initial supply is minted to the deployer address.
     * @param initialOwner The address that receives the initial supply and admin role.
     */
{{- if .NeedsOwnable}}
    constructor(address initialOwner)
        ERC20({{.Name | quote}}, {{.Symbol | quote}})
{{- if .Permit}}
        ERC20Permit({{.Name | quote}})
{{- end}}
{{- if .MaxSupply}}
        ERC20Capped({{.MaxSupply}} * 10 ** decimals())
{{- end}}
        Ownable(initialOwner)
    {
{{- else if .NeedsRoles}}
    constructor(address defaultAdmin)
        ERC20({{.Name | quote}}, {{.Symbol | quote}})
{{- if .Permit}}
        ERC20Permit({{.Name | quote}})
{{- end}}
{{- if .MaxSupply}}
        ERC20Capped({{.MaxSupply}} * 10 ** decimals())
{{- end}}
    {
        _grantRole(DEFAULT_ADMIN_ROLE, defaultAdmin);
        _grantRole(MINTER_ROLE, defaultAdmin);
        _grantRole(PAUSER_ROLE, defaultAdmin);
{{- if .Snapshot}}
        _grantRole(SNAPSHOT_ROLE, defaultAdmin);
{{- end}}
{{- else}}
    constructor()
        ERC20({{.Name | quote}}, {{.Symbol | quote}})
{{- if .Permit}}
        ERC20Permit({{.Name | quote}})
{{- end}}
    {
{{- end}}
{{- if .InitialSupply}}
        // Mint initial supply to deployer.
        // NOTE: decimals() is called after ERC20 is initialized, safe here.
        _mint({{- if .NeedsOwnable}}initialOwner{{- else if .NeedsRoles}}defaultAdmin{{- else}}msg.sender{{- end}}, {{.InitialSupply}} * 10 ** decimals());
{{- end}}
    }
{{- if ne .Decimals 18}}

    /**
     * @dev Overrides the default 18 decimals.
     */
    function decimals() public pure override returns (uint8) {
        return {{.Decimals}};
    }
{{- end}}
{{- if .Mintable}}

    /**
     * @dev Mints `amount` tokens to `to`.
{{- if .NeedsOwnable}}
     * Requirements: caller must be the owner.
{{- else if .NeedsRoles}}
     * Requirements: caller must have MINTER_ROLE.
{{- end}}
     * @param to Recipient address — must not be the zero address.
     * @param amount Amount in smallest unit (wei-equivalent).
     */
{{- if .NeedsOwnable}}
    function mint(address to, uint256 amount) external onlyOwner {
{{- else if .NeedsRoles}}
    function mint(address to, uint256 amount) external onlyRole(MINTER_ROLE) {
{{- else}}
    function mint(address to, uint256 amount) external {
{{- end}}
        _mint(to, amount);
    }
{{- end}}
{{- if .Pausable}}

    /**
     * @dev Pauses all token transfers. Emergency use only.
{{- if .NeedsOwnable}}
     * Requirements: caller must be the owner.
{{- else if .NeedsRoles}}
     * Requirements: caller must have PAUSER_ROLE.
{{- end}}
     */
{{- if .NeedsOwnable}}
    function pause() external onlyOwner {
{{- else if .NeedsRoles}}
    function pause() external onlyRole(PAUSER_ROLE) {
{{- else}}
    function pause() external {
{{- end}}
        _pause();
    }

    /**
     * @dev Unpauses all token transfers.
     */
{{- if .NeedsOwnable}}
    function unpause() external onlyOwner {
{{- else if .NeedsRoles}}
    function unpause() external onlyRole(PAUSER_ROLE) {
{{- else}}
    function unpause() external {
{{- end}}
        _unpause();
    }
{{- end}}
{{- if .Snapshot}}

    /**
     * @dev Takes a snapshot of current balances. Returns snapshot ID.
{{- if .NeedsOwnable}}
     * Requirements: caller must be the owner.
{{- else if .NeedsRoles}}
     * Requirements: caller must have SNAPSHOT_ROLE.
{{- end}}
     */
{{- if .NeedsOwnable}}
    function snapshot() external onlyOwner returns (uint256) {
{{- else if .NeedsRoles}}
    function snapshot() external onlyRole(SNAPSHOT_ROLE) returns (uint256) {
{{- else}}
    function snapshot() external returns (uint256) {
{{- end}}
        return _snapshot();
    }
{{- end}}

    // ─── Internal overrides ──────────────────────────────────────────────────

    function _update(address from, address to, uint256 value)
        internal
        override(ERC20{{- if .Pausable}}, ERC20Pausable{{end}}{{- if .Snapshot}}, ERC20Snapshot{{end}}{{- if .MaxSupply}}, ERC20Capped{{end}}{{- if .Votes}}, ERC20Votes{{end}})
    {
        super._update(from, to, value);
    }
{{- if .NeedsRoles}}

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC20{{- if .Snapshot}}, ERC20Snapshot{{end}}, AccessControl)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
{{- end}}
}
