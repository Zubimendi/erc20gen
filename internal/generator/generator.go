package generator

import (
	"bytes"
	"strings"
	"text/template"

	"github.com/Zubimendi/erc20gen/internal/config"
)

// Generator holds config and renders templates.
type Generator struct {
	cfg *config.TokenConfig
}

// New creates a new Generator.
func New(cfg *config.TokenConfig) *Generator {
	return &Generator{cfg: cfg}
}

// GenerateContract renders the Solidity ERC-20 contract.
func (g *Generator) GenerateContract() (string, error) {
	tmpl, err := template.New("contract").Funcs(templateFuncs()).Parse(contractTemplate)
	if err != nil {
		return "", err
	}
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, g.cfg); err != nil {
		return "", err
	}
	return buf.String(), nil
}

// GenerateDeployScript renders a Hardhat deploy script (JS).
func (g *Generator) GenerateDeployScript() (string, error) {
	tmpl, err := template.New("deploy").Funcs(templateFuncs()).Parse(deployTemplate)
	if err != nil {
		return "", err
	}
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, g.cfg); err != nil {
		return "", err
	}
	return buf.String(), nil
}

// GenerateTestSkeleton renders a Hardhat test skeleton (JS).
func (g *Generator) GenerateTestSkeleton() (string, error) {
	tmpl, err := template.New("test").Funcs(templateFuncs()).Parse(testTemplate)
	if err != nil {
		return "", err
	}
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, g.cfg); err != nil {
		return "", err
	}
	return buf.String(), nil
}

func templateFuncs() template.FuncMap {
	return template.FuncMap{
		"join":  strings.Join,
		"upper": strings.ToUpper,
		"lower": strings.ToLower,
		"quote": func(s string) string { return `"` + s + `"` },
		"add":   func(a, b int) int { return a + b },
	}
}

// ─── Solidity Contract Template ──────────────────────────────────────────────

const contractTemplate = `// SPDX-License-Identifier: {{.License}}
// Generated by erc20gen — https://github.com/Zubimendi/erc20gen
// ⚠️  SECURITY: Audit this contract before deploying to mainnet.
// Run: slither contracts/{{.ContractFileName}} && echidna-test . --contract {{.SafeName}}
pragma solidity {{.SolidityVersion}};

{{- range .ImportPaths}}
import "{{.}}";
{{- end}}

/**
 * @title {{.Name}}
 * @dev ERC-20 Token — {{.Symbol}}
 *
 * Features:
{{- if .Mintable}}
 *   ✓ Mintable        — authorized callers can mint new tokens
{{- end}}
{{- if .Burnable}}
 *   ✓ Burnable        — token holders can burn their balance
{{- end}}
{{- if .Pausable}}
 *   ✓ Pausable        — emergency pause of all transfers
{{- end}}
{{- if .Permit}}
 *   ✓ Permit (2612)   — gasless approvals via EIP-2612 signatures
{{- end}}
{{- if .Snapshot}}
 *   ✓ Snapshot        — balance snapshots for governance
{{- end}}
{{- if .Votes}}
 *   ✓ Votes           — on-chain voting delegation
{{- end}}
{{- if .MaxSupply}}
 *   ✓ Capped Supply   — maximum {{.MaxSupply}} tokens
{{- end}}
 *
 * Access Control: {{.AccessControl}}
 * Generated: erc20gen v1.0.0
 */
contract {{.SafeName}} is ERC20{{- range .InheritanceList}}, {{.}}{{end}} {
{{- if .NeedsRoles}}

    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant SNAPSHOT_ROLE = keccak256("SNAPSHOT_ROLE");
{{- end}}

    /**
     * @dev Initializes the token with name, symbol, and initial supply.
     *      Initial supply is minted to the deployer address.
     * @param initialOwner The address that receives the initial supply and admin role.
     */
{{- if .NeedsOwnable}}
    constructor(address initialOwner)
        ERC20({{.Name | quote}}, {{.Symbol | quote}})
{{- if .Permit}}
        ERC20Permit({{.Name | quote}})
{{- end}}
{{- if .MaxSupply}}
        ERC20Capped({{.MaxSupply}} * 10 ** decimals())
{{- end}}
        Ownable(initialOwner)
    {
{{- else if .NeedsRoles}}
    constructor(address defaultAdmin)
        ERC20({{.Name | quote}}, {{.Symbol | quote}})
{{- if .Permit}}
        ERC20Permit({{.Name | quote}})
{{- end}}
{{- if .MaxSupply}}
        ERC20Capped({{.MaxSupply}} * 10 ** decimals())
{{- end}}
    {
        _grantRole(DEFAULT_ADMIN_ROLE, defaultAdmin);
        _grantRole(MINTER_ROLE, defaultAdmin);
        _grantRole(PAUSER_ROLE, defaultAdmin);
{{- if .Snapshot}}
        _grantRole(SNAPSHOT_ROLE, defaultAdmin);
{{- end}}
{{- else}}
    constructor()
        ERC20({{.Name | quote}}, {{.Symbol | quote}})
{{- if .Permit}}
        ERC20Permit({{.Name | quote}})
{{- end}}
    {
{{- end}}
{{- if .InitialSupply}}
        // Mint initial supply to deployer.
        // NOTE: decimals() is called after ERC20 is initialized, safe here.
        _mint({{- if .NeedsOwnable}}initialOwner{{- else if .NeedsRoles}}defaultAdmin{{- else}}msg.sender{{- end}}, {{.InitialSupply}} * 10 ** decimals());
{{- end}}
    }
{{- if ne .Decimals 18}}

    /**
     * @dev Overrides the default 18 decimals.
     */
    function decimals() public pure override returns (uint8) {
        return {{.Decimals}};
    }
{{- end}}
{{- if .Mintable}}

    /**
     * @dev Mints `amount` tokens to `to`.
{{- if .NeedsOwnable}}
     * Requirements: caller must be the owner.
{{- else if .NeedsRoles}}
     * Requirements: caller must have MINTER_ROLE.
{{- end}}
     * @param to Recipient address — must not be the zero address.
     * @param amount Amount in smallest unit (wei-equivalent).
     */
{{- if .NeedsOwnable}}
    function mint(address to, uint256 amount) external onlyOwner {
{{- else if .NeedsRoles}}
    function mint(address to, uint256 amount) external onlyRole(MINTER_ROLE) {
{{- else}}
    function mint(address to, uint256 amount) external {
{{- end}}
        _mint(to, amount);
    }
{{- end}}
{{- if .Pausable}}

    /**
     * @dev Pauses all token transfers. Emergency use only.
{{- if .NeedsOwnable}}
     * Requirements: caller must be the owner.
{{- else if .NeedsRoles}}
     * Requirements: caller must have PAUSER_ROLE.
{{- end}}
     */
{{- if .NeedsOwnable}}
    function pause() external onlyOwner {
{{- else if .NeedsRoles}}
    function pause() external onlyRole(PAUSER_ROLE) {
{{- else}}
    function pause() external {
{{- end}}
        _pause();
    }

    /**
     * @dev Unpauses all token transfers.
     */
{{- if .NeedsOwnable}}
    function unpause() external onlyOwner {
{{- else if .NeedsRoles}}
    function unpause() external onlyRole(PAUSER_ROLE) {
{{- else}}
    function unpause() external {
{{- end}}
        _unpause();
    }
{{- end}}
{{- if .Snapshot}}

    /**
     * @dev Takes a snapshot of current balances. Returns snapshot ID.
{{- if .NeedsOwnable}}
     * Requirements: caller must be the owner.
{{- else if .NeedsRoles}}
     * Requirements: caller must have SNAPSHOT_ROLE.
{{- end}}
     */
{{- if .NeedsOwnable}}
    function snapshot() external onlyOwner returns (uint256) {
{{- else if .NeedsRoles}}
    function snapshot() external onlyRole(SNAPSHOT_ROLE) returns (uint256) {
{{- else}}
    function snapshot() external returns (uint256) {
{{- end}}
        return _snapshot();
    }
{{- end}}

    // ─── Internal overrides ──────────────────────────────────────────────────

    function _update(address from, address to, uint256 value)
        internal
        override(ERC20{{- if .Pausable}}, ERC20Pausable{{end}}{{- if .Snapshot}}, ERC20Snapshot{{end}}{{- if .MaxSupply}}, ERC20Capped{{end}}{{- if .Votes}}, ERC20Votes{{end}})
    {
        super._update(from, to, value);
    }
{{- if .NeedsRoles}}

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC20{{- if .Snapshot}}, ERC20Snapshot{{end}}, AccessControl)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
{{- end}}
}
`

// ─── Hardhat Deploy Script Template ──────────────────────────────────────────

const deployTemplate = `// Hardhat deployment script for {{.Name}} ({{.Symbol}})
// Generated by erc20gen — https://github.com/Zubimendi/erc20gen
//
// Usage:
//   npx hardhat run scripts/deploy_{{.SafeName}}.js --network <network>
//
// Security checklist before deploying:
//   1. Set DEPLOYER_PRIVATE_KEY in .env (never commit this file!)
//   2. Verify contract source on Etherscan after deployment
//   3. Transfer ownership if needed BEFORE publicizing the contract

const { ethers } = require("hardhat");

async function main() {
  const [deployer] = await ethers.getSigners();
  console.log("Deploying {{.Name}} with account:", deployer.address);
  console.log("Account balance:", (await deployer.provider.getBalance(deployer.address)).toString());

  const {{.SafeName}} = await ethers.getContractFactory("{{.SafeName}}");

{{- if .NeedsOwnable}}
  // Pass initialOwner — receives initial supply and admin rights
  const token = await {{.SafeName}}.deploy(deployer.address);
{{- else if .NeedsRoles}}
  // Pass defaultAdmin — receives all roles
  const token = await {{.SafeName}}.deploy(deployer.address);
{{- else}}
  const token = await {{.SafeName}}.deploy();
{{- end}}

  await token.waitForDeployment();
  const address = await token.getAddress();

  console.log("\n✅ {{.Name}} deployed to:", address);
  console.log("   Symbol:         {{.Symbol}}");
  console.log("   Decimals:       {{.Decimals}}");
{{- if .InitialSupply}}
  console.log("   Initial Supply: {{.InitialSupply}} tokens");
{{- end}}
{{- if .MaxSupply}}
  console.log("   Max Supply:     {{.MaxSupply}} tokens");
{{- end}}

  // Verify on Etherscan (requires ETHERSCAN_API_KEY in hardhat.config.js)
  if (process.env.ETHERSCAN_API_KEY) {
    console.log("\nWaiting for block confirmations before verification...");
    await token.deploymentTransaction().wait(6);
    await hre.run("verify:verify", {
      address,
      constructorArguments: [deployer.address],
    });
  }
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
`

// ─── Hardhat Test Skeleton Template ──────────────────────────────────────────

const testTemplate = `// Test suite for {{.Name}} ({{.Symbol}})
// Generated by erc20gen — https://github.com/Zubimendi/erc20gen
// Framework: Hardhat + Chai
// Run: npx hardhat test

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { loadFixture } = require("@nomicfoundation/hardhat-toolbox/network-helpers");

describe("{{.SafeName}}", function () {
  // ─── Fixtures ──────────────────────────────────────────────────────────────

  async function deployFixture() {
    const [owner, addr1, addr2, ...addrs] = await ethers.getSigners();
    const {{.SafeName}} = await ethers.getContractFactory("{{.SafeName}}");
{{- if or .NeedsOwnable .NeedsRoles}}
    const token = await {{.SafeName}}.deploy(owner.address);
{{- else}}
    const token = await {{.SafeName}}.deploy();
{{- end}}
    await token.waitForDeployment();
    return { token, owner, addr1, addr2, addrs };
  }

  // ─── Deployment ────────────────────────────────────────────────────────────

  describe("Deployment", function () {
    it("Should have correct name and symbol", async function () {
      const { token } = await loadFixture(deployFixture);
      expect(await token.name()).to.equal("{{.Name}}");
      expect(await token.symbol()).to.equal("{{.Symbol}}");
    });

    it("Should have {{.Decimals}} decimals", async function () {
      const { token } = await loadFixture(deployFixture);
      expect(await token.decimals()).to.equal({{.Decimals}});
    });
{{- if .InitialSupply}}

    it("Should mint initial supply to deployer", async function () {
      const { token, owner } = await loadFixture(deployFixture);
      const decimals = await token.decimals();
      const expected = ethers.parseUnits("{{.InitialSupply}}", decimals);
      expect(await token.totalSupply()).to.equal(expected);
      expect(await token.balanceOf(owner.address)).to.equal(expected);
    });
{{- end}}
{{- if .MaxSupply}}

    it("Should have correct cap", async function () {
      const { token } = await loadFixture(deployFixture);
      const decimals = await token.decimals();
      const expectedCap = ethers.parseUnits("{{.MaxSupply}}", decimals);
      expect(await token.cap()).to.equal(expectedCap);
    });
{{- end}}
  });

  // ─── Transfers ─────────────────────────────────────────────────────────────

  describe("Transfers", function () {
    it("Should transfer tokens between accounts", async function () {
      const { token, owner, addr1 } = await loadFixture(deployFixture);
      const amount = ethers.parseUnits("100", await token.decimals());
      await expect(token.transfer(addr1.address, amount))
        .to.emit(token, "Transfer")
        .withArgs(owner.address, addr1.address, amount);
    });

    it("Should fail when sender has insufficient balance", async function () {
      const { token, addr1, addr2 } = await loadFixture(deployFixture);
      const amount = ethers.parseUnits("1", await token.decimals());
      await expect(token.connect(addr1).transfer(addr2.address, amount))
        .to.be.revertedWithCustomError(token, "ERC20InsufficientBalance");
    });

    it("Should not allow transfer to zero address", async function () {
      const { token, owner } = await loadFixture(deployFixture);
      const amount = ethers.parseUnits("1", await token.decimals());
      await expect(token.transfer(ethers.ZeroAddress, amount))
        .to.be.revertedWithCustomError(token, "ERC20InvalidReceiver");
    });
  });

  // ─── Approvals ─────────────────────────────────────────────────────────────

  describe("Approvals", function () {
    it("Should approve and transferFrom correctly", async function () {
      const { token, owner, addr1, addr2 } = await loadFixture(deployFixture);
      const amount = ethers.parseUnits("50", await token.decimals());
      await token.approve(addr1.address, amount);
      await token.connect(addr1).transferFrom(owner.address, addr2.address, amount);
      expect(await token.balanceOf(addr2.address)).to.equal(amount);
    });

    it("Should emit Approval event", async function () {
      const { token, owner, addr1 } = await loadFixture(deployFixture);
      const amount = ethers.parseUnits("100", await token.decimals());
      await expect(token.approve(addr1.address, amount))
        .to.emit(token, "Approval")
        .withArgs(owner.address, addr1.address, amount);
    });
  });
{{- if .Mintable}}

  // ─── Minting ───────────────────────────────────────────────────────────────

  describe("Minting", function () {
    it("Should allow authorized minting", async function () {
      const { token, owner, addr1 } = await loadFixture(deployFixture);
      const amount = ethers.parseUnits("500", await token.decimals());
      await expect(token.mint(addr1.address, amount))
        .to.emit(token, "Transfer")
        .withArgs(ethers.ZeroAddress, addr1.address, amount);
    });

    it("Should reject unauthorized minting", async function () {
      const { token, addr1, addr2 } = await loadFixture(deployFixture);
      const amount = ethers.parseUnits("1", await token.decimals());
      await expect(token.connect(addr1).mint(addr2.address, amount))
        .to.be.reverted;
    });

    it("Should not allow minting to zero address", async function () {
      const { token } = await loadFixture(deployFixture);
      const amount = ethers.parseUnits("1", await token.decimals());
      await expect(token.mint(ethers.ZeroAddress, amount))
        .to.be.revertedWithCustomError(token, "ERC20InvalidReceiver");
    });
  });
{{- end}}
{{- if .Burnable}}

  // ─── Burning ───────────────────────────────────────────────────────────────

  describe("Burning", function () {
    it("Should allow token holders to burn their tokens", async function () {
      const { token, owner } = await loadFixture(deployFixture);
      const amount = ethers.parseUnits("100", await token.decimals());
      const balanceBefore = await token.balanceOf(owner.address);
      await token.burn(amount);
      expect(await token.balanceOf(owner.address)).to.equal(balanceBefore - amount);
    });

    it("Should reduce total supply on burn", async function () {
      const { token, owner } = await loadFixture(deployFixture);
      const amount = ethers.parseUnits("100", await token.decimals());
      const supplyBefore = await token.totalSupply();
      await token.burn(amount);
      expect(await token.totalSupply()).to.equal(supplyBefore - amount);
    });
  });
{{- end}}
{{- if .Pausable}}

  // ─── Pause ─────────────────────────────────────────────────────────────────

  describe("Pausable", function () {
    it("Should block transfers when paused", async function () {
      const { token, owner, addr1 } = await loadFixture(deployFixture);
      await token.pause();
      const amount = ethers.parseUnits("1", await token.decimals());
      await expect(token.transfer(addr1.address, amount))
        .to.be.revertedWithCustomError(token, "EnforcedPause");
    });

    it("Should allow transfers after unpause", async function () {
      const { token, owner, addr1 } = await loadFixture(deployFixture);
      await token.pause();
      await token.unpause();
      const amount = ethers.parseUnits("1", await token.decimals());
      await expect(token.transfer(addr1.address, amount)).not.to.be.reverted;
    });

    it("Should reject pause from non-authorized caller", async function () {
      const { token, addr1 } = await loadFixture(deployFixture);
      await expect(token.connect(addr1).pause()).to.be.reverted;
    });
  });
{{- end}}

  // ─── Security edge cases ───────────────────────────────────────────────────

  describe("Security", function () {
    it("Should handle zero amount transfers gracefully", async function () {
      const { token, owner, addr1 } = await loadFixture(deployFixture);
      await expect(token.transfer(addr1.address, 0)).not.to.be.reverted;
    });

    it("Should handle max uint256 approval (infinite approval pattern)", async function () {
      const { token, owner, addr1 } = await loadFixture(deployFixture);
      const maxUint = ethers.MaxUint256;
      await token.approve(addr1.address, maxUint);
      expect(await token.allowance(owner.address, addr1.address)).to.equal(maxUint);
    });
  });
});
`