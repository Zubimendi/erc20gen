// Test suite for gyokeres (G14)
// Generated by erc20gen — https://github.com/Zubimendi/erc20gen
// Framework: Hardhat + Chai
// Run: npx hardhat test

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { loadFixture } = require("@nomicfoundation/hardhat-toolbox/network-helpers");

describe("gyokeres", function () {
  // ─── Fixtures ──────────────────────────────────────────────────────────────

  async function deployFixture() {
    const [owner, addr1, addr2, ...addrs] = await ethers.getSigners();
    const gyokeres = await ethers.getContractFactory("gyokeres");
    const token = await gyokeres.deploy(owner.address);
    await token.waitForDeployment();
    return { token, owner, addr1, addr2, addrs };
  }

  // ─── Deployment ────────────────────────────────────────────────────────────

  describe("Deployment", function () {
    it("Should have correct name and symbol", async function () {
      const { token } = await loadFixture(deployFixture);
      expect(await token.name()).to.equal("gyokeres");
      expect(await token.symbol()).to.equal("G14");
    });

    it("Should have 6 decimals", async function () {
      const { token } = await loadFixture(deployFixture);
      expect(await token.decimals()).to.equal(6);
    });

    it("Should mint initial supply to deployer", async function () {
      const { token, owner } = await loadFixture(deployFixture);
      const decimals = await token.decimals();
      const expected = ethers.parseUnits("1000000", decimals);
      expect(await token.totalSupply()).to.equal(expected);
      expect(await token.balanceOf(owner.address)).to.equal(expected);
    });

    it("Should have correct cap", async function () {
      const { token } = await loadFixture(deployFixture);
      const decimals = await token.decimals();
      const expectedCap = ethers.parseUnits("1000000", decimals);
      expect(await token.cap()).to.equal(expectedCap);
    });
  });

  // ─── Transfers ─────────────────────────────────────────────────────────────

  describe("Transfers", function () {
    it("Should transfer tokens between accounts", async function () {
      const { token, owner, addr1 } = await loadFixture(deployFixture);
      const amount = ethers.parseUnits("100", await token.decimals());
      await expect(token.transfer(addr1.address, amount))
        .to.emit(token, "Transfer")
        .withArgs(owner.address, addr1.address, amount);
    });

    it("Should fail when sender has insufficient balance", async function () {
      const { token, addr1, addr2 } = await loadFixture(deployFixture);
      const amount = ethers.parseUnits("1", await token.decimals());
      await expect(token.connect(addr1).transfer(addr2.address, amount))
        .to.be.revertedWithCustomError(token, "ERC20InsufficientBalance");
    });

    it("Should not allow transfer to zero address", async function () {
      const { token, owner } = await loadFixture(deployFixture);
      const amount = ethers.parseUnits("1", await token.decimals());
      await expect(token.transfer(ethers.ZeroAddress, amount))
        .to.be.revertedWithCustomError(token, "ERC20InvalidReceiver");
    });
  });

  // ─── Approvals ─────────────────────────────────────────────────────────────

  describe("Approvals", function () {
    it("Should approve and transferFrom correctly", async function () {
      const { token, owner, addr1, addr2 } = await loadFixture(deployFixture);
      const amount = ethers.parseUnits("50", await token.decimals());
      await token.approve(addr1.address, amount);
      await token.connect(addr1).transferFrom(owner.address, addr2.address, amount);
      expect(await token.balanceOf(addr2.address)).to.equal(amount);
    });

    it("Should emit Approval event", async function () {
      const { token, owner, addr1 } = await loadFixture(deployFixture);
      const amount = ethers.parseUnits("100", await token.decimals());
      await expect(token.approve(addr1.address, amount))
        .to.emit(token, "Approval")
        .withArgs(owner.address, addr1.address, amount);
    });
  });

  // ─── Security edge cases ───────────────────────────────────────────────────

  describe("Security", function () {
    it("Should handle zero amount transfers gracefully", async function () {
      const { token, owner, addr1 } = await loadFixture(deployFixture);
      await expect(token.transfer(addr1.address, 0)).not.to.be.reverted;
    });

    it("Should handle max uint256 approval (infinite approval pattern)", async function () {
      const { token, owner, addr1 } = await loadFixture(deployFixture);
      const maxUint = ethers.MaxUint256;
      await token.approve(addr1.address, maxUint);
      expect(await token.allowance(owner.address, addr1.address)).to.equal(maxUint);
    });
  });
});
